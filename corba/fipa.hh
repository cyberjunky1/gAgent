// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __fipa_hh__
#define __fipa_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_fipa
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_fipa
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_fipa
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE FIPA

_CORBA_MODULE_BEG

  typedef char* URL;
  typedef ::CORBA::String_var URL_var;
  typedef ::CORBA::String_out URL_out;

  class strings_var;

  class strings : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef strings_var _var_type;
    inline strings() {}
    inline strings(const strings& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline strings(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline strings(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline strings& operator = (const strings& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class strings_out;

  class strings_var {
  public:
    inline strings_var() : _pd_seq(0) {}
    inline strings_var(strings* _s) : _pd_seq(_s) {}
    inline strings_var(const strings_var& _s) {
      if( _s._pd_seq )  _pd_seq = new strings(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~strings_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline strings_var& operator = (strings* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline strings_var& operator = (const strings_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new strings;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline strings* operator -> () { return _pd_seq; }
    inline const strings* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator strings& () const { return *_pd_seq; }
#else
    inline operator const strings& () const { return *_pd_seq; }
    inline operator strings& () { return *_pd_seq; }
#endif
      
    inline const strings& in() const { return *_pd_seq; }
    inline strings&       inout()    { return *_pd_seq; }
    inline strings*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline strings* _retn() { strings* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class strings_out;
    
  private:
    strings* _pd_seq;
  };

  class strings_out {
  public:
    inline strings_out(strings*& _s) : _data(_s) { _data = 0; }
    inline strings_out(strings_var& _s)
      : _data(_s._pd_seq) { _s = (strings*) 0; }
    inline strings_out(const strings_out& _s) : _data(_s._data) {}
    inline strings_out& operator = (const strings_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline strings_out& operator = (strings* _s) {
      _data = _s;
      return *this;
    }
    inline operator strings*&()  { return _data; }
    inline strings*& ptr()       { return _data; }
    inline strings* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    strings*& _data;

  private:
    strings_out();
    strings_out& operator=(const strings_var&);
  };

  struct Property {
    typedef _CORBA_ConstrType_Variable_Var<Property> _var_type;

    
    ::CORBA::String_member keyword;

    ::CORBA::Any value;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Property::_var_type Property_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Property,Property_var > Property_out;

  struct AgentID {
    typedef _CORBA_ConstrType_Variable_Var<AgentID> _var_type;

    
    ::CORBA::String_member name;

    typedef _CORBA_Unbounded_Sequence_String _addresses_seq;
    _addresses_seq addresses;

    typedef _CORBA_Unbounded_Sequence< AgentID >  _resolvers_seq;
    _resolvers_seq resolvers;

    typedef _CORBA_Unbounded_Sequence< Property >  _userDefinedProperties_seq;
    _userDefinedProperties_seq userDefinedProperties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef AgentID::_var_type AgentID_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< AgentID,AgentID_var > AgentID_out;

  class AgentIDs_var;

  class AgentIDs : public _CORBA_Unbounded_Sequence< AgentID >  {
  public:
    typedef AgentIDs_var _var_type;
    inline AgentIDs() {}
    inline AgentIDs(const AgentIDs& _s)
      : _CORBA_Unbounded_Sequence< AgentID > (_s) {}

    inline AgentIDs(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< AgentID > (_max) {}
    inline AgentIDs(_CORBA_ULong _max, _CORBA_ULong _len, AgentID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< AgentID > (_max, _len, _val, _rel) {}

  

    inline AgentIDs& operator = (const AgentIDs& _s) {
      _CORBA_Unbounded_Sequence< AgentID > ::operator=(_s);
      return *this;
    }
  };

  class AgentIDs_out;

  class AgentIDs_var {
  public:
    inline AgentIDs_var() : _pd_seq(0) {}
    inline AgentIDs_var(AgentIDs* _s) : _pd_seq(_s) {}
    inline AgentIDs_var(const AgentIDs_var& _s) {
      if( _s._pd_seq )  _pd_seq = new AgentIDs(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~AgentIDs_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline AgentIDs_var& operator = (AgentIDs* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline AgentIDs_var& operator = (const AgentIDs_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new AgentIDs;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline AgentID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline AgentIDs* operator -> () { return _pd_seq; }
    inline const AgentIDs* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator AgentIDs& () const { return *_pd_seq; }
#else
    inline operator const AgentIDs& () const { return *_pd_seq; }
    inline operator AgentIDs& () { return *_pd_seq; }
#endif
      
    inline const AgentIDs& in() const { return *_pd_seq; }
    inline AgentIDs&       inout()    { return *_pd_seq; }
    inline AgentIDs*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline AgentIDs* _retn() { AgentIDs* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class AgentIDs_out;
    
  private:
    AgentIDs* _pd_seq;
  };

  class AgentIDs_out {
  public:
    inline AgentIDs_out(AgentIDs*& _s) : _data(_s) { _data = 0; }
    inline AgentIDs_out(AgentIDs_var& _s)
      : _data(_s._pd_seq) { _s = (AgentIDs*) 0; }
    inline AgentIDs_out(const AgentIDs_out& _s) : _data(_s._data) {}
    inline AgentIDs_out& operator = (const AgentIDs_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline AgentIDs_out& operator = (AgentIDs* _s) {
      _data = _s;
      return *this;
    }
    inline operator AgentIDs*&()  { return _data; }
    inline AgentIDs*& ptr()       { return _data; }
    inline AgentIDs* operator->() { return _data; }

    inline AgentID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    AgentIDs*& _data;

  private:
    AgentIDs_out();
    AgentIDs_out& operator=(const AgentIDs_var&);
  };

  struct DateTime {
    typedef _CORBA_ConstrType_Fix_Var<DateTime> _var_type;

    
    ::CORBA::Short year;

    ::CORBA::Short month;

    ::CORBA::Short day;

    ::CORBA::Short hour;

    ::CORBA::Short minutes;

    ::CORBA::Short seconds;

    ::CORBA::Short milliseconds;

    ::CORBA::Char typeDesignator;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef DateTime::_var_type DateTime_var;

  typedef DateTime& DateTime_out;

  struct ReceivedObject {
    typedef _CORBA_ConstrType_Variable_Var<ReceivedObject> _var_type;

    
    ::CORBA::String_member by;

    ::CORBA::String_member from;

    DateTime date;

    ::CORBA::String_member id;

    ::CORBA::String_member via;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef ReceivedObject::_var_type ReceivedObject_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< ReceivedObject,ReceivedObject_var > ReceivedObject_out;

  class TransportBehaviourType_var;

  class TransportBehaviourType : public _CORBA_Unbounded_Sequence< Property >  {
  public:
    typedef TransportBehaviourType_var _var_type;
    inline TransportBehaviourType() {}
    inline TransportBehaviourType(const TransportBehaviourType& _s)
      : _CORBA_Unbounded_Sequence< Property > (_s) {}

    inline TransportBehaviourType(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Property > (_max) {}
    inline TransportBehaviourType(_CORBA_ULong _max, _CORBA_ULong _len, Property* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Property > (_max, _len, _val, _rel) {}

  

    inline TransportBehaviourType& operator = (const TransportBehaviourType& _s) {
      _CORBA_Unbounded_Sequence< Property > ::operator=(_s);
      return *this;
    }
  };

  class TransportBehaviourType_out;

  class TransportBehaviourType_var {
  public:
    inline TransportBehaviourType_var() : _pd_seq(0) {}
    inline TransportBehaviourType_var(TransportBehaviourType* _s) : _pd_seq(_s) {}
    inline TransportBehaviourType_var(const TransportBehaviourType_var& _s) {
      if( _s._pd_seq )  _pd_seq = new TransportBehaviourType(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~TransportBehaviourType_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline TransportBehaviourType_var& operator = (TransportBehaviourType* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline TransportBehaviourType_var& operator = (const TransportBehaviourType_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new TransportBehaviourType;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Property& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline TransportBehaviourType* operator -> () { return _pd_seq; }
    inline const TransportBehaviourType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator TransportBehaviourType& () const { return *_pd_seq; }
#else
    inline operator const TransportBehaviourType& () const { return *_pd_seq; }
    inline operator TransportBehaviourType& () { return *_pd_seq; }
#endif
      
    inline const TransportBehaviourType& in() const { return *_pd_seq; }
    inline TransportBehaviourType&       inout()    { return *_pd_seq; }
    inline TransportBehaviourType*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline TransportBehaviourType* _retn() { TransportBehaviourType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class TransportBehaviourType_out;
    
  private:
    TransportBehaviourType* _pd_seq;
  };

  class TransportBehaviourType_out {
  public:
    inline TransportBehaviourType_out(TransportBehaviourType*& _s) : _data(_s) { _data = 0; }
    inline TransportBehaviourType_out(TransportBehaviourType_var& _s)
      : _data(_s._pd_seq) { _s = (TransportBehaviourType*) 0; }
    inline TransportBehaviourType_out(const TransportBehaviourType_out& _s) : _data(_s._data) {}
    inline TransportBehaviourType_out& operator = (const TransportBehaviourType_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline TransportBehaviourType_out& operator = (TransportBehaviourType* _s) {
      _data = _s;
      return *this;
    }
    inline operator TransportBehaviourType*&()  { return _data; }
    inline TransportBehaviourType*& ptr()       { return _data; }
    inline TransportBehaviourType* operator->() { return _data; }

    inline Property& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    TransportBehaviourType*& _data;

  private:
    TransportBehaviourType_out();
    TransportBehaviourType_out& operator=(const TransportBehaviourType_var&);
  };

  class OptAgentID_var;

  class OptAgentID : public _CORBA_Bounded_Sequence< AgentID, 1 >  {
  public:
    typedef OptAgentID_var _var_type;
    inline OptAgentID() {}
    inline OptAgentID(const OptAgentID& _s)
      : _CORBA_Bounded_Sequence< AgentID, 1 > (_s) {}

    inline OptAgentID(_CORBA_ULong _len, AgentID* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence< AgentID, 1 > (_len, _val, _rel) {}

  

    inline OptAgentID& operator = (const OptAgentID& _s) {
      _CORBA_Bounded_Sequence< AgentID, 1 > ::operator=(_s);
      return *this;
    }
  };

  class OptAgentID_out;

  class OptAgentID_var {
  public:
    inline OptAgentID_var() : _pd_seq(0) {}
    inline OptAgentID_var(OptAgentID* _s) : _pd_seq(_s) {}
    inline OptAgentID_var(const OptAgentID_var& _s) {
      if( _s._pd_seq )  _pd_seq = new OptAgentID(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~OptAgentID_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline OptAgentID_var& operator = (OptAgentID* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline OptAgentID_var& operator = (const OptAgentID_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new OptAgentID;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline AgentID& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline OptAgentID* operator -> () { return _pd_seq; }
    inline const OptAgentID* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator OptAgentID& () const { return *_pd_seq; }
#else
    inline operator const OptAgentID& () const { return *_pd_seq; }
    inline operator OptAgentID& () { return *_pd_seq; }
#endif
      
    inline const OptAgentID& in() const { return *_pd_seq; }
    inline OptAgentID&       inout()    { return *_pd_seq; }
    inline OptAgentID*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline OptAgentID* _retn() { OptAgentID* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class OptAgentID_out;
    
  private:
    OptAgentID* _pd_seq;
  };

  class OptAgentID_out {
  public:
    inline OptAgentID_out(OptAgentID*& _s) : _data(_s) { _data = 0; }
    inline OptAgentID_out(OptAgentID_var& _s)
      : _data(_s._pd_seq) { _s = (OptAgentID*) 0; }
    inline OptAgentID_out(const OptAgentID_out& _s) : _data(_s._data) {}
    inline OptAgentID_out& operator = (const OptAgentID_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline OptAgentID_out& operator = (OptAgentID* _s) {
      _data = _s;
      return *this;
    }
    inline operator OptAgentID*&()  { return _data; }
    inline OptAgentID*& ptr()       { return _data; }
    inline OptAgentID* operator->() { return _data; }

    inline AgentID& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    OptAgentID*& _data;

  private:
    OptAgentID_out();
    OptAgentID_out& operator=(const OptAgentID_var&);
  };

  class OptDateTime_var;

  class OptDateTime : public _CORBA_Bounded_Sequence< DateTime, 1 >  {
  public:
    typedef OptDateTime_var _var_type;
    inline OptDateTime() {}
    inline OptDateTime(const OptDateTime& _s)
      : _CORBA_Bounded_Sequence< DateTime, 1 > (_s) {}

    inline OptDateTime(_CORBA_ULong _len, DateTime* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence< DateTime, 1 > (_len, _val, _rel) {}

  

    inline OptDateTime& operator = (const OptDateTime& _s) {
      _CORBA_Bounded_Sequence< DateTime, 1 > ::operator=(_s);
      return *this;
    }
  };

  class OptDateTime_out;

  class OptDateTime_var {
  public:
    inline OptDateTime_var() : _pd_seq(0) {}
    inline OptDateTime_var(OptDateTime* _s) : _pd_seq(_s) {}
    inline OptDateTime_var(const OptDateTime_var& _s) {
      if( _s._pd_seq )  _pd_seq = new OptDateTime(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~OptDateTime_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline OptDateTime_var& operator = (OptDateTime* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline OptDateTime_var& operator = (const OptDateTime_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new OptDateTime;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline DateTime& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline OptDateTime* operator -> () { return _pd_seq; }
    inline const OptDateTime* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator OptDateTime& () const { return *_pd_seq; }
#else
    inline operator const OptDateTime& () const { return *_pd_seq; }
    inline operator OptDateTime& () { return *_pd_seq; }
#endif
      
    inline const OptDateTime& in() const { return *_pd_seq; }
    inline OptDateTime&       inout()    { return *_pd_seq; }
    inline OptDateTime*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline OptDateTime* _retn() { OptDateTime* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class OptDateTime_out;
    
  private:
    OptDateTime* _pd_seq;
  };

  class OptDateTime_out {
  public:
    inline OptDateTime_out(OptDateTime*& _s) : _data(_s) { _data = 0; }
    inline OptDateTime_out(OptDateTime_var& _s)
      : _data(_s._pd_seq) { _s = (OptDateTime*) 0; }
    inline OptDateTime_out(const OptDateTime_out& _s) : _data(_s._data) {}
    inline OptDateTime_out& operator = (const OptDateTime_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline OptDateTime_out& operator = (OptDateTime* _s) {
      _data = _s;
      return *this;
    }
    inline operator OptDateTime*&()  { return _data; }
    inline OptDateTime*& ptr()       { return _data; }
    inline OptDateTime* operator->() { return _data; }

    inline DateTime& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    OptDateTime*& _data;

  private:
    OptDateTime_out();
    OptDateTime_out& operator=(const OptDateTime_var&);
  };

  class OptTransportBehaviourType_var;

  class OptTransportBehaviourType : public _CORBA_Bounded_Sequence< TransportBehaviourType, 1 >  {
  public:
    typedef OptTransportBehaviourType_var _var_type;
    inline OptTransportBehaviourType() {}
    inline OptTransportBehaviourType(const OptTransportBehaviourType& _s)
      : _CORBA_Bounded_Sequence< TransportBehaviourType, 1 > (_s) {}

    inline OptTransportBehaviourType(_CORBA_ULong _len, TransportBehaviourType* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence< TransportBehaviourType, 1 > (_len, _val, _rel) {}

  

    inline OptTransportBehaviourType& operator = (const OptTransportBehaviourType& _s) {
      _CORBA_Bounded_Sequence< TransportBehaviourType, 1 > ::operator=(_s);
      return *this;
    }
  };

  class OptTransportBehaviourType_out;

  class OptTransportBehaviourType_var {
  public:
    inline OptTransportBehaviourType_var() : _pd_seq(0) {}
    inline OptTransportBehaviourType_var(OptTransportBehaviourType* _s) : _pd_seq(_s) {}
    inline OptTransportBehaviourType_var(const OptTransportBehaviourType_var& _s) {
      if( _s._pd_seq )  _pd_seq = new OptTransportBehaviourType(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~OptTransportBehaviourType_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline OptTransportBehaviourType_var& operator = (OptTransportBehaviourType* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline OptTransportBehaviourType_var& operator = (const OptTransportBehaviourType_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new OptTransportBehaviourType;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline TransportBehaviourType& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline OptTransportBehaviourType* operator -> () { return _pd_seq; }
    inline const OptTransportBehaviourType* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator OptTransportBehaviourType& () const { return *_pd_seq; }
#else
    inline operator const OptTransportBehaviourType& () const { return *_pd_seq; }
    inline operator OptTransportBehaviourType& () { return *_pd_seq; }
#endif
      
    inline const OptTransportBehaviourType& in() const { return *_pd_seq; }
    inline OptTransportBehaviourType&       inout()    { return *_pd_seq; }
    inline OptTransportBehaviourType*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline OptTransportBehaviourType* _retn() { OptTransportBehaviourType* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class OptTransportBehaviourType_out;
    
  private:
    OptTransportBehaviourType* _pd_seq;
  };

  class OptTransportBehaviourType_out {
  public:
    inline OptTransportBehaviourType_out(OptTransportBehaviourType*& _s) : _data(_s) { _data = 0; }
    inline OptTransportBehaviourType_out(OptTransportBehaviourType_var& _s)
      : _data(_s._pd_seq) { _s = (OptTransportBehaviourType*) 0; }
    inline OptTransportBehaviourType_out(const OptTransportBehaviourType_out& _s) : _data(_s._data) {}
    inline OptTransportBehaviourType_out& operator = (const OptTransportBehaviourType_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline OptTransportBehaviourType_out& operator = (OptTransportBehaviourType* _s) {
      _data = _s;
      return *this;
    }
    inline operator OptTransportBehaviourType*&()  { return _data; }
    inline OptTransportBehaviourType*& ptr()       { return _data; }
    inline OptTransportBehaviourType* operator->() { return _data; }

    inline TransportBehaviourType& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    OptTransportBehaviourType*& _data;

  private:
    OptTransportBehaviourType_out();
    OptTransportBehaviourType_out& operator=(const OptTransportBehaviourType_var&);
  };

  class OptReceivedObject_var;

  class OptReceivedObject : public _CORBA_Bounded_Sequence< ReceivedObject, 1 >  {
  public:
    typedef OptReceivedObject_var _var_type;
    inline OptReceivedObject() {}
    inline OptReceivedObject(const OptReceivedObject& _s)
      : _CORBA_Bounded_Sequence< ReceivedObject, 1 > (_s) {}

    inline OptReceivedObject(_CORBA_ULong _len, ReceivedObject* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Bounded_Sequence< ReceivedObject, 1 > (_len, _val, _rel) {}

  

    inline OptReceivedObject& operator = (const OptReceivedObject& _s) {
      _CORBA_Bounded_Sequence< ReceivedObject, 1 > ::operator=(_s);
      return *this;
    }
  };

  class OptReceivedObject_out;

  class OptReceivedObject_var {
  public:
    inline OptReceivedObject_var() : _pd_seq(0) {}
    inline OptReceivedObject_var(OptReceivedObject* _s) : _pd_seq(_s) {}
    inline OptReceivedObject_var(const OptReceivedObject_var& _s) {
      if( _s._pd_seq )  _pd_seq = new OptReceivedObject(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~OptReceivedObject_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline OptReceivedObject_var& operator = (OptReceivedObject* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline OptReceivedObject_var& operator = (const OptReceivedObject_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new OptReceivedObject;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ReceivedObject& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline OptReceivedObject* operator -> () { return _pd_seq; }
    inline const OptReceivedObject* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator OptReceivedObject& () const { return *_pd_seq; }
#else
    inline operator const OptReceivedObject& () const { return *_pd_seq; }
    inline operator OptReceivedObject& () { return *_pd_seq; }
#endif
      
    inline const OptReceivedObject& in() const { return *_pd_seq; }
    inline OptReceivedObject&       inout()    { return *_pd_seq; }
    inline OptReceivedObject*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline OptReceivedObject* _retn() { OptReceivedObject* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class OptReceivedObject_out;
    
  private:
    OptReceivedObject* _pd_seq;
  };

  class OptReceivedObject_out {
  public:
    inline OptReceivedObject_out(OptReceivedObject*& _s) : _data(_s) { _data = 0; }
    inline OptReceivedObject_out(OptReceivedObject_var& _s)
      : _data(_s._pd_seq) { _s = (OptReceivedObject*) 0; }
    inline OptReceivedObject_out(const OptReceivedObject_out& _s) : _data(_s._data) {}
    inline OptReceivedObject_out& operator = (const OptReceivedObject_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline OptReceivedObject_out& operator = (OptReceivedObject* _s) {
      _data = _s;
      return *this;
    }
    inline operator OptReceivedObject*&()  { return _data; }
    inline OptReceivedObject*& ptr()       { return _data; }
    inline OptReceivedObject* operator->() { return _data; }

    inline ReceivedObject& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    OptReceivedObject*& _data;

  private:
    OptReceivedObject_out();
    OptReceivedObject_out& operator=(const OptReceivedObject_var&);
  };

  struct Envelope {
    typedef _CORBA_ConstrType_Variable_Var<Envelope> _var_type;

    
    AgentIDs to;

    OptAgentID from;

    ::CORBA::String_member comments;

    ::CORBA::String_member aclRepresentation;

    ::CORBA::Long payloadLength;

    ::CORBA::String_member payloadEncoding;

    OptDateTime date;

    strings encrypted;

    AgentIDs intendedReceiver;

    OptReceivedObject received;

    OptTransportBehaviourType transportBehaviour;

    typedef _CORBA_Unbounded_Sequence< Property >  _userDefinedProperties_seq;
    _userDefinedProperties_seq userDefinedProperties;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef Envelope::_var_type Envelope_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< Envelope,Envelope_var > Envelope_out;

  class Envelopes_var;

  class Envelopes : public _CORBA_Unbounded_Sequence< Envelope >  {
  public:
    typedef Envelopes_var _var_type;
    inline Envelopes() {}
    inline Envelopes(const Envelopes& _s)
      : _CORBA_Unbounded_Sequence< Envelope > (_s) {}

    inline Envelopes(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence< Envelope > (_max) {}
    inline Envelopes(_CORBA_ULong _max, _CORBA_ULong _len, Envelope* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence< Envelope > (_max, _len, _val, _rel) {}

  

    inline Envelopes& operator = (const Envelopes& _s) {
      _CORBA_Unbounded_Sequence< Envelope > ::operator=(_s);
      return *this;
    }
  };

  class Envelopes_out;

  class Envelopes_var {
  public:
    inline Envelopes_var() : _pd_seq(0) {}
    inline Envelopes_var(Envelopes* _s) : _pd_seq(_s) {}
    inline Envelopes_var(const Envelopes_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Envelopes(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Envelopes_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Envelopes_var& operator = (Envelopes* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Envelopes_var& operator = (const Envelopes_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Envelopes;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline Envelope& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Envelopes* operator -> () { return _pd_seq; }
    inline const Envelopes* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Envelopes& () const { return *_pd_seq; }
#else
    inline operator const Envelopes& () const { return *_pd_seq; }
    inline operator Envelopes& () { return *_pd_seq; }
#endif
      
    inline const Envelopes& in() const { return *_pd_seq; }
    inline Envelopes&       inout()    { return *_pd_seq; }
    inline Envelopes*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Envelopes* _retn() { Envelopes* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Envelopes_out;
    
  private:
    Envelopes* _pd_seq;
  };

  class Envelopes_out {
  public:
    inline Envelopes_out(Envelopes*& _s) : _data(_s) { _data = 0; }
    inline Envelopes_out(Envelopes_var& _s)
      : _data(_s._pd_seq) { _s = (Envelopes*) 0; }
    inline Envelopes_out(const Envelopes_out& _s) : _data(_s._data) {}
    inline Envelopes_out& operator = (const Envelopes_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Envelopes_out& operator = (Envelopes* _s) {
      _data = _s;
      return *this;
    }
    inline operator Envelopes*&()  { return _data; }
    inline Envelopes*& ptr()       { return _data; }
    inline Envelopes* operator->() { return _data; }

    inline Envelope& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Envelopes*& _data;

  private:
    Envelopes_out();
    Envelopes_out& operator=(const Envelopes_var&);
  };

  class Payload_var;

  class Payload : public _CORBA_Unbounded_Sequence_Octet {
  public:
    typedef Payload_var _var_type;
    inline Payload() {}
    inline Payload(const Payload& _s)
      : _CORBA_Unbounded_Sequence_Octet(_s) {}

    inline Payload(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Octet(_max) {}
    inline Payload(_CORBA_ULong _max, _CORBA_ULong _len, ::CORBA::Octet* _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Octet(_max, _len, _val, _rel) {}

  

    inline Payload& operator = (const Payload& _s) {
      _CORBA_Unbounded_Sequence_Octet::operator=(_s);
      return *this;
    }
  };

  class Payload_out;

  class Payload_var {
  public:
    inline Payload_var() : _pd_seq(0) {}
    inline Payload_var(Payload* _s) : _pd_seq(_s) {}
    inline Payload_var(const Payload_var& _s) {
      if( _s._pd_seq )  _pd_seq = new Payload(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~Payload_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline Payload_var& operator = (Payload* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline Payload_var& operator = (const Payload_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new Payload;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline ::CORBA::Octet& operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline Payload* operator -> () { return _pd_seq; }
    inline const Payload* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator Payload& () const { return *_pd_seq; }
#else
    inline operator const Payload& () const { return *_pd_seq; }
    inline operator Payload& () { return *_pd_seq; }
#endif
      
    inline const Payload& in() const { return *_pd_seq; }
    inline Payload&       inout()    { return *_pd_seq; }
    inline Payload*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline Payload* _retn() { Payload* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class Payload_out;
    
  private:
    Payload* _pd_seq;
  };

  class Payload_out {
  public:
    inline Payload_out(Payload*& _s) : _data(_s) { _data = 0; }
    inline Payload_out(Payload_var& _s)
      : _data(_s._pd_seq) { _s = (Payload*) 0; }
    inline Payload_out(const Payload_out& _s) : _data(_s._data) {}
    inline Payload_out& operator = (const Payload_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline Payload_out& operator = (Payload* _s) {
      _data = _s;
      return *this;
    }
    inline operator Payload*&()  { return _data; }
    inline Payload*& ptr()       { return _data; }
    inline Payload* operator->() { return _data; }

    inline ::CORBA::Octet& operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    Payload*& _data;

  private:
    Payload_out();
    Payload_out& operator=(const Payload_var&);
  };

  struct FipaMessage {
    typedef _CORBA_ConstrType_Variable_Var<FipaMessage> _var_type;

    
    Envelopes messageEnvelopes;

    Payload messageBody;

  

    void operator>>= (cdrStream &) const;
    void operator<<= (cdrStream &);
  };

  typedef FipaMessage::_var_type FipaMessage_var;

  typedef _CORBA_ConstrType_Variable_OUT_arg< FipaMessage,FipaMessage_var > FipaMessage_out;

#ifndef __FIPA_mMTS__
#define __FIPA_mMTS__

  class MTS;
  class _objref_MTS;
  class _impl_MTS;
  
  typedef _objref_MTS* MTS_ptr;
  typedef MTS_ptr MTSRef;

  class MTS_Helper {
  public:
    typedef MTS_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_MTS, MTS_Helper> MTS_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_MTS,MTS_Helper > MTS_out;

#endif

  // interface MTS
  class MTS {
  public:
    // Declarations for this interface type.
    typedef MTS_ptr _ptr_type;
    typedef MTS_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_MTS :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    void message(const ::FIPA::FipaMessage& aFipaMessage);

    inline _objref_MTS()  { _PR_setobj(0); }  // nil
    _objref_MTS(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_MTS();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_MTS(const _objref_MTS&);
    _objref_MTS& operator = (const _objref_MTS&);
    // not implemented

    friend class MTS;
  };

  class _pof_MTS : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_MTS() : _OMNI_NS(proxyObjectFactory)(MTS::_PD_repoId) {}
    virtual ~_pof_MTS();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_MTS :
    public virtual omniServant
  {
  public:
    virtual ~_impl_MTS();

    virtual void message(const ::FIPA::FipaMessage& aFipaMessage) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_FIPA
_CORBA_MODULE_BEG

  class MTS :
    public virtual FIPA::_impl_MTS,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~MTS();

    inline ::FIPA::MTS_ptr _this() {
      return (::FIPA::MTS_ptr) _do_this(::FIPA::MTS::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_FIPA
_CORBA_MODULE_BEG

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
FIPA::MTS::_marshalObjRef(::FIPA::MTS_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_fipa
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_fipa
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_fipa
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_fipa
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_fipa
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_fipa
#endif

#endif  // __fipa_hh__

